// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perception_component.proto

#ifndef PROTOBUF_perception_5fcomponent_2eproto__INCLUDED
#define PROTOBUF_perception_5fcomponent_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace perception {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perception_5fcomponent_2eproto();
void protobuf_AssignDesc_perception_5fcomponent_2eproto();
void protobuf_ShutdownFile_perception_5fcomponent_2eproto();

class CameraComponentInitOptions;
class FusionComponentInitOptions;
class InputSensor;
class LidarComponentInitOptions;
class Roi;
class Vector3;
class VirtualObject;

// ===================================================================

class Vector3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.Vector3) */ {
 public:
  Vector3();
  virtual ~Vector3();

  Vector3(const Vector3& from);

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3& default_instance();

  void Swap(Vector3* other);

  // implements Message ----------------------------------------------

  inline Vector3* New() const { return New(NULL); }

  Vector3* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3& from);
  void MergeFrom(const Vector3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:perception.Vector3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_AddDesc_perception_5fcomponent_2eproto();
  friend void protobuf_AssignDesc_perception_5fcomponent_2eproto();
  friend void protobuf_ShutdownFile_perception_5fcomponent_2eproto();

  void InitAsDefaultInstance();
  static Vector3* default_instance_;
};
// -------------------------------------------------------------------

class Roi : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.Roi) */ {
 public:
  Roi();
  virtual ~Roi();

  Roi(const Roi& from);

  inline Roi& operator=(const Roi& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Roi& default_instance();

  void Swap(Roi* other);

  // implements Message ----------------------------------------------

  inline Roi* New() const { return New(NULL); }

  Roi* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Roi& from);
  void MergeFrom(const Roi& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Roi* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float roi_x_min = 1;
  bool has_roi_x_min() const;
  void clear_roi_x_min();
  static const int kRoiXMinFieldNumber = 1;
  float roi_x_min() const;
  void set_roi_x_min(float value);

  // optional float roi_x_max = 2;
  bool has_roi_x_max() const;
  void clear_roi_x_max();
  static const int kRoiXMaxFieldNumber = 2;
  float roi_x_max() const;
  void set_roi_x_max(float value);

  // optional float roi_y_min = 3;
  bool has_roi_y_min() const;
  void clear_roi_y_min();
  static const int kRoiYMinFieldNumber = 3;
  float roi_y_min() const;
  void set_roi_y_min(float value);

  // optional float roi_y_max = 4;
  bool has_roi_y_max() const;
  void clear_roi_y_max();
  static const int kRoiYMaxFieldNumber = 4;
  float roi_y_max() const;
  void set_roi_y_max(float value);

  // optional float roi_z_min = 5;
  bool has_roi_z_min() const;
  void clear_roi_z_min();
  static const int kRoiZMinFieldNumber = 5;
  float roi_z_min() const;
  void set_roi_z_min(float value);

  // optional float roi_z_max = 6;
  bool has_roi_z_max() const;
  void clear_roi_z_max();
  static const int kRoiZMaxFieldNumber = 6;
  float roi_z_max() const;
  void set_roi_z_max(float value);

  // @@protoc_insertion_point(class_scope:perception.Roi)
 private:
  inline void set_has_roi_x_min();
  inline void clear_has_roi_x_min();
  inline void set_has_roi_x_max();
  inline void clear_has_roi_x_max();
  inline void set_has_roi_y_min();
  inline void clear_has_roi_y_min();
  inline void set_has_roi_y_max();
  inline void clear_has_roi_y_max();
  inline void set_has_roi_z_min();
  inline void clear_has_roi_z_min();
  inline void set_has_roi_z_max();
  inline void clear_has_roi_z_max();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float roi_x_min_;
  float roi_x_max_;
  float roi_y_min_;
  float roi_y_max_;
  float roi_z_min_;
  float roi_z_max_;
  friend void  protobuf_AddDesc_perception_5fcomponent_2eproto();
  friend void protobuf_AssignDesc_perception_5fcomponent_2eproto();
  friend void protobuf_ShutdownFile_perception_5fcomponent_2eproto();

  void InitAsDefaultInstance();
  static Roi* default_instance_;
};
// -------------------------------------------------------------------

class InputSensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.InputSensor) */ {
 public:
  InputSensor();
  virtual ~InputSensor();

  InputSensor(const InputSensor& from);

  inline InputSensor& operator=(const InputSensor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputSensor& default_instance();

  void Swap(InputSensor* other);

  // implements Message ----------------------------------------------

  inline InputSensor* New() const { return New(NULL); }

  InputSensor* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputSensor& from);
  void MergeFrom(const InputSensor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InputSensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sensor_name = 1;
  bool has_sensor_name() const;
  void clear_sensor_name();
  static const int kSensorNameFieldNumber = 1;
  const ::std::string& sensor_name() const;
  void set_sensor_name(const ::std::string& value);
  void set_sensor_name(const char* value);
  void set_sensor_name(const char* value, size_t size);
  ::std::string* mutable_sensor_name();
  ::std::string* release_sensor_name();
  void set_allocated_sensor_name(::std::string* sensor_name);

  // optional string topic = 2;
  bool has_topic() const;
  void clear_topic();
  static const int kTopicFieldNumber = 2;
  const ::std::string& topic() const;
  void set_topic(const ::std::string& value);
  void set_topic(const char* value);
  void set_topic(const char* value, size_t size);
  ::std::string* mutable_topic();
  ::std::string* release_topic();
  void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:perception.InputSensor)
 private:
  inline void set_has_sensor_name();
  inline void clear_has_sensor_name();
  inline void set_has_topic();
  inline void clear_has_topic();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sensor_name_;
  ::google::protobuf::internal::ArenaStringPtr topic_;
  friend void  protobuf_AddDesc_perception_5fcomponent_2eproto();
  friend void protobuf_AssignDesc_perception_5fcomponent_2eproto();
  friend void protobuf_ShutdownFile_perception_5fcomponent_2eproto();

  void InitAsDefaultInstance();
  static InputSensor* default_instance_;
};
// -------------------------------------------------------------------

class LidarComponentInitOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.LidarComponentInitOptions) */ {
 public:
  LidarComponentInitOptions();
  virtual ~LidarComponentInitOptions();

  LidarComponentInitOptions(const LidarComponentInitOptions& from);

  inline LidarComponentInitOptions& operator=(const LidarComponentInitOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LidarComponentInitOptions& default_instance();

  void Swap(LidarComponentInitOptions* other);

  // implements Message ----------------------------------------------

  inline LidarComponentInitOptions* New() const { return New(NULL); }

  LidarComponentInitOptions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LidarComponentInitOptions& from);
  void MergeFrom(const LidarComponentInitOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LidarComponentInitOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string input_sensor = 1;
  bool has_input_sensor() const;
  void clear_input_sensor();
  static const int kInputSensorFieldNumber = 1;
  const ::std::string& input_sensor() const;
  void set_input_sensor(const ::std::string& value);
  void set_input_sensor(const char* value);
  void set_input_sensor(const char* value, size_t size);
  ::std::string* mutable_input_sensor();
  ::std::string* release_input_sensor();
  void set_allocated_input_sensor(::std::string* input_sensor);

  // optional .perception.Roi roi = 2;
  bool has_roi() const;
  void clear_roi();
  static const int kRoiFieldNumber = 2;
  const ::perception::Roi& roi() const;
  ::perception::Roi* mutable_roi();
  ::perception::Roi* release_roi();
  void set_allocated_roi(::perception::Roi* roi);

  // optional float sensor_height = 4;
  bool has_sensor_height() const;
  void clear_sensor_height();
  static const int kSensorHeightFieldNumber = 4;
  float sensor_height() const;
  void set_sensor_height(float value);

  // optional float downsampling_radius = 5 [default = 0.06];
  bool has_downsampling_radius() const;
  void clear_downsampling_radius();
  static const int kDownsamplingRadiusFieldNumber = 5;
  float downsampling_radius() const;
  void set_downsampling_radius(float value);

  // optional int32 num_lpr = 6;
  bool has_num_lpr() const;
  void clear_num_lpr();
  static const int kNumLprFieldNumber = 6;
  ::google::protobuf::int32 num_lpr() const;
  void set_num_lpr(::google::protobuf::int32 value);

  // optional float th_dist = 7;
  bool has_th_dist() const;
  void clear_th_dist();
  static const int kThDistFieldNumber = 7;
  float th_dist() const;
  void set_th_dist(float value);

  // optional float th_seeds = 8;
  bool has_th_seeds() const;
  void clear_th_seeds();
  static const int kThSeedsFieldNumber = 8;
  float th_seeds() const;
  void set_th_seeds(float value);

  // optional float min_distance = 9;
  bool has_min_distance() const;
  void clear_min_distance();
  static const int kMinDistanceFieldNumber = 9;
  float min_distance() const;
  void set_min_distance(float value);

  // optional bool publish_cluster = 10 [default = false];
  bool has_publish_cluster() const;
  void clear_publish_cluster();
  static const int kPublishClusterFieldNumber = 10;
  bool publish_cluster() const;
  void set_publish_cluster(bool value);

  // @@protoc_insertion_point(class_scope:perception.LidarComponentInitOptions)
 private:
  inline void set_has_input_sensor();
  inline void clear_has_input_sensor();
  inline void set_has_roi();
  inline void clear_has_roi();
  inline void set_has_sensor_height();
  inline void clear_has_sensor_height();
  inline void set_has_downsampling_radius();
  inline void clear_has_downsampling_radius();
  inline void set_has_num_lpr();
  inline void clear_has_num_lpr();
  inline void set_has_th_dist();
  inline void clear_has_th_dist();
  inline void set_has_th_seeds();
  inline void clear_has_th_seeds();
  inline void set_has_min_distance();
  inline void clear_has_min_distance();
  inline void set_has_publish_cluster();
  inline void clear_has_publish_cluster();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr input_sensor_;
  ::perception::Roi* roi_;
  float sensor_height_;
  float downsampling_radius_;
  ::google::protobuf::int32 num_lpr_;
  float th_dist_;
  float th_seeds_;
  float min_distance_;
  bool publish_cluster_;
  friend void  protobuf_AddDesc_perception_5fcomponent_2eproto();
  friend void protobuf_AssignDesc_perception_5fcomponent_2eproto();
  friend void protobuf_ShutdownFile_perception_5fcomponent_2eproto();

  void InitAsDefaultInstance();
  static LidarComponentInitOptions* default_instance_;
};
// -------------------------------------------------------------------

class CameraComponentInitOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.CameraComponentInitOptions) */ {
 public:
  CameraComponentInitOptions();
  virtual ~CameraComponentInitOptions();

  CameraComponentInitOptions(const CameraComponentInitOptions& from);

  inline CameraComponentInitOptions& operator=(const CameraComponentInitOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraComponentInitOptions& default_instance();

  void Swap(CameraComponentInitOptions* other);

  // implements Message ----------------------------------------------

  inline CameraComponentInitOptions* New() const { return New(NULL); }

  CameraComponentInitOptions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraComponentInitOptions& from);
  void MergeFrom(const CameraComponentInitOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CameraComponentInitOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string input_sensor = 1;
  bool has_input_sensor() const;
  void clear_input_sensor();
  static const int kInputSensorFieldNumber = 1;
  const ::std::string& input_sensor() const;
  void set_input_sensor(const ::std::string& value);
  void set_input_sensor(const char* value);
  void set_input_sensor(const char* value, size_t size);
  ::std::string* mutable_input_sensor();
  ::std::string* release_input_sensor();
  void set_allocated_input_sensor(::std::string* input_sensor);

  // optional string load_serialize_path = 2 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_load_serialize_path() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_load_serialize_path();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kLoadSerializePathFieldNumber = 2;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::std::string& load_serialize_path() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_load_serialize_path(const ::std::string& value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_load_serialize_path(const char* value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_load_serialize_path(const char* value, size_t size);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_load_serialize_path();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* release_load_serialize_path();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_load_serialize_path(::std::string* load_serialize_path);

  // optional string load_class_names = 3 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_load_class_names() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_load_class_names();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kLoadClassNamesFieldNumber = 3;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::std::string& load_class_names() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_load_class_names(const ::std::string& value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_load_class_names(const char* value);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_load_class_names(const char* value, size_t size);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* mutable_load_class_names();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::std::string* release_load_class_names();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_load_class_names(::std::string* load_class_names);

  // optional string publish_objects = 6;
  bool has_publish_objects() const;
  void clear_publish_objects();
  static const int kPublishObjectsFieldNumber = 6;
  const ::std::string& publish_objects() const;
  void set_publish_objects(const ::std::string& value);
  void set_publish_objects(const char* value);
  void set_publish_objects(const char* value, size_t size);
  ::std::string* mutable_publish_objects();
  ::std::string* release_publish_objects();
  void set_allocated_publish_objects(::std::string* publish_objects);

  // @@protoc_insertion_point(class_scope:perception.CameraComponentInitOptions)
 private:
  inline void set_has_input_sensor();
  inline void clear_has_input_sensor();
  inline void set_has_load_serialize_path();
  inline void clear_has_load_serialize_path();
  inline void set_has_load_class_names();
  inline void clear_has_load_class_names();
  inline void set_has_publish_objects();
  inline void clear_has_publish_objects();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr input_sensor_;
  ::google::protobuf::internal::ArenaStringPtr load_serialize_path_;
  ::google::protobuf::internal::ArenaStringPtr load_class_names_;
  ::google::protobuf::internal::ArenaStringPtr publish_objects_;
  friend void  protobuf_AddDesc_perception_5fcomponent_2eproto();
  friend void protobuf_AssignDesc_perception_5fcomponent_2eproto();
  friend void protobuf_ShutdownFile_perception_5fcomponent_2eproto();

  void InitAsDefaultInstance();
  static CameraComponentInitOptions* default_instance_;
};
// -------------------------------------------------------------------

class VirtualObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.VirtualObject) */ {
 public:
  VirtualObject();
  virtual ~VirtualObject();

  VirtualObject(const VirtualObject& from);

  inline VirtualObject& operator=(const VirtualObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VirtualObject& default_instance();

  void Swap(VirtualObject* other);

  // implements Message ----------------------------------------------

  inline VirtualObject* New() const { return New(NULL); }

  VirtualObject* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VirtualObject& from);
  void MergeFrom(const VirtualObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VirtualObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional .perception.Vector3 position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::perception::Vector3& position() const;
  ::perception::Vector3* mutable_position();
  ::perception::Vector3* release_position();
  void set_allocated_position(::perception::Vector3* position);

  // optional .perception.Vector3 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  const ::perception::Vector3& size() const;
  ::perception::Vector3* mutable_size();
  ::perception::Vector3* release_size();
  void set_allocated_size(::perception::Vector3* size);

  // optional double yaw = 4;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 4;
  double yaw() const;
  void set_yaw(double value);

  // @@protoc_insertion_point(class_scope:perception.VirtualObject)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_yaw();
  inline void clear_has_yaw();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perception::Vector3* position_;
  ::perception::Vector3* size_;
  double yaw_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_perception_5fcomponent_2eproto();
  friend void protobuf_AssignDesc_perception_5fcomponent_2eproto();
  friend void protobuf_ShutdownFile_perception_5fcomponent_2eproto();

  void InitAsDefaultInstance();
  static VirtualObject* default_instance_;
};
// -------------------------------------------------------------------

class FusionComponentInitOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:perception.FusionComponentInitOptions) */ {
 public:
  FusionComponentInitOptions();
  virtual ~FusionComponentInitOptions();

  FusionComponentInitOptions(const FusionComponentInitOptions& from);

  inline FusionComponentInitOptions& operator=(const FusionComponentInitOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FusionComponentInitOptions& default_instance();

  void Swap(FusionComponentInitOptions* other);

  // implements Message ----------------------------------------------

  inline FusionComponentInitOptions* New() const { return New(NULL); }

  FusionComponentInitOptions* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FusionComponentInitOptions& from);
  void MergeFrom(const FusionComponentInitOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FusionComponentInitOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool use_lidar = 1 [default = true];
  bool has_use_lidar() const;
  void clear_use_lidar();
  static const int kUseLidarFieldNumber = 1;
  bool use_lidar() const;
  void set_use_lidar(bool value);

  // optional bool use_radar = 2 [default = false];
  bool has_use_radar() const;
  void clear_use_radar();
  static const int kUseRadarFieldNumber = 2;
  bool use_radar() const;
  void set_use_radar(bool value);

  // optional bool use_camera = 3 [default = true];
  bool has_use_camera() const;
  void clear_use_camera();
  static const int kUseCameraFieldNumber = 3;
  bool use_camera() const;
  void set_use_camera(bool value);

  // repeated .perception.InputSensor input_sensor = 4;
  int input_sensor_size() const;
  void clear_input_sensor();
  static const int kInputSensorFieldNumber = 4;
  const ::perception::InputSensor& input_sensor(int index) const;
  ::perception::InputSensor* mutable_input_sensor(int index);
  ::perception::InputSensor* add_input_sensor();
  ::google::protobuf::RepeatedPtrField< ::perception::InputSensor >*
      mutable_input_sensor();
  const ::google::protobuf::RepeatedPtrField< ::perception::InputSensor >&
      input_sensor() const;

  // optional string fusion_method = 5;
  bool has_fusion_method() const;
  void clear_fusion_method();
  static const int kFusionMethodFieldNumber = 5;
  const ::std::string& fusion_method() const;
  void set_fusion_method(const ::std::string& value);
  void set_fusion_method(const char* value);
  void set_fusion_method(const char* value, size_t size);
  ::std::string* mutable_fusion_method();
  ::std::string* release_fusion_method();
  void set_allocated_fusion_method(::std::string* fusion_method);

  // repeated string fusion_main_sensors = 6;
  int fusion_main_sensors_size() const;
  void clear_fusion_main_sensors();
  static const int kFusionMainSensorsFieldNumber = 6;
  const ::std::string& fusion_main_sensors(int index) const;
  ::std::string* mutable_fusion_main_sensors(int index);
  void set_fusion_main_sensors(int index, const ::std::string& value);
  void set_fusion_main_sensors(int index, const char* value);
  void set_fusion_main_sensors(int index, const char* value, size_t size);
  ::std::string* add_fusion_main_sensors();
  void add_fusion_main_sensors(const ::std::string& value);
  void add_fusion_main_sensors(const char* value);
  void add_fusion_main_sensors(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fusion_main_sensors() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fusion_main_sensors();

  // optional bool object_in_roi_check = 7;
  bool has_object_in_roi_check() const;
  void clear_object_in_roi_check();
  static const int kObjectInRoiCheckFieldNumber = 7;
  bool object_in_roi_check() const;
  void set_object_in_roi_check(bool value);

  // optional double radius_for_roi_object_check = 8;
  bool has_radius_for_roi_object_check() const;
  void clear_radius_for_roi_object_check();
  static const int kRadiusForRoiObjectCheckFieldNumber = 8;
  double radius_for_roi_object_check() const;
  void set_radius_for_roi_object_check(double value);

  // optional string localization_topic = 9;
  bool has_localization_topic() const;
  void clear_localization_topic();
  static const int kLocalizationTopicFieldNumber = 9;
  const ::std::string& localization_topic() const;
  void set_localization_topic(const ::std::string& value);
  void set_localization_topic(const char* value);
  void set_localization_topic(const char* value, size_t size);
  ::std::string* mutable_localization_topic();
  ::std::string* release_localization_topic();
  void set_allocated_localization_topic(::std::string* localization_topic);

  // optional string output_obstacles_topic_name = 10;
  bool has_output_obstacles_topic_name() const;
  void clear_output_obstacles_topic_name();
  static const int kOutputObstaclesTopicNameFieldNumber = 10;
  const ::std::string& output_obstacles_topic_name() const;
  void set_output_obstacles_topic_name(const ::std::string& value);
  void set_output_obstacles_topic_name(const char* value);
  void set_output_obstacles_topic_name(const char* value, size_t size);
  ::std::string* mutable_output_obstacles_topic_name();
  ::std::string* release_output_obstacles_topic_name();
  void set_allocated_output_obstacles_topic_name(::std::string* output_obstacles_topic_name);

  // optional string output_obstacles_topic_name_app = 11;
  bool has_output_obstacles_topic_name_app() const;
  void clear_output_obstacles_topic_name_app();
  static const int kOutputObstaclesTopicNameAppFieldNumber = 11;
  const ::std::string& output_obstacles_topic_name_app() const;
  void set_output_obstacles_topic_name_app(const ::std::string& value);
  void set_output_obstacles_topic_name_app(const char* value);
  void set_output_obstacles_topic_name_app(const char* value, size_t size);
  ::std::string* mutable_output_obstacles_topic_name_app();
  ::std::string* release_output_obstacles_topic_name_app();
  void set_allocated_output_obstacles_topic_name_app(::std::string* output_obstacles_topic_name_app);

  // optional string output_viz_fused_box_topic_name = 12;
  bool has_output_viz_fused_box_topic_name() const;
  void clear_output_viz_fused_box_topic_name();
  static const int kOutputVizFusedBoxTopicNameFieldNumber = 12;
  const ::std::string& output_viz_fused_box_topic_name() const;
  void set_output_viz_fused_box_topic_name(const ::std::string& value);
  void set_output_viz_fused_box_topic_name(const char* value);
  void set_output_viz_fused_box_topic_name(const char* value, size_t size);
  ::std::string* mutable_output_viz_fused_box_topic_name();
  ::std::string* release_output_viz_fused_box_topic_name();
  void set_allocated_output_viz_fused_box_topic_name(::std::string* output_viz_fused_box_topic_name);

  // optional string output_viz_fused_text_topic_name = 13;
  bool has_output_viz_fused_text_topic_name() const;
  void clear_output_viz_fused_text_topic_name();
  static const int kOutputVizFusedTextTopicNameFieldNumber = 13;
  const ::std::string& output_viz_fused_text_topic_name() const;
  void set_output_viz_fused_text_topic_name(const ::std::string& value);
  void set_output_viz_fused_text_topic_name(const char* value);
  void set_output_viz_fused_text_topic_name(const char* value, size_t size);
  ::std::string* mutable_output_viz_fused_text_topic_name();
  ::std::string* release_output_viz_fused_text_topic_name();
  void set_allocated_output_viz_fused_text_topic_name(::std::string* output_viz_fused_text_topic_name);

  // optional bool enable_publish_fusion_topic = 14 [default = true];
  bool has_enable_publish_fusion_topic() const;
  void clear_enable_publish_fusion_topic();
  static const int kEnablePublishFusionTopicFieldNumber = 14;
  bool enable_publish_fusion_topic() const;
  void set_enable_publish_fusion_topic(bool value);

  // optional bool enable_publish_fusion_topic_app = 15 [default = true];
  bool has_enable_publish_fusion_topic_app() const;
  void clear_enable_publish_fusion_topic_app();
  static const int kEnablePublishFusionTopicAppFieldNumber = 15;
  bool enable_publish_fusion_topic_app() const;
  void set_enable_publish_fusion_topic_app(bool value);

  // optional bool use_obu = 16 [default = true];
  bool has_use_obu() const;
  void clear_use_obu();
  static const int kUseObuFieldNumber = 16;
  bool use_obu() const;
  void set_use_obu(bool value);

  // optional bool use_vidar = 17 [default = false];
  bool has_use_vidar() const;
  void clear_use_vidar();
  static const int kUseVidarFieldNumber = 17;
  bool use_vidar() const;
  void set_use_vidar(bool value);

  // optional bool pub_vidar = 18 [default = false];
  bool has_pub_vidar() const;
  void clear_pub_vidar();
  static const int kPubVidarFieldNumber = 18;
  bool pub_vidar() const;
  void set_pub_vidar(bool value);

  // optional bool pub_radar = 19 [default = false];
  bool has_pub_radar() const;
  void clear_pub_radar();
  static const int kPubRadarFieldNumber = 19;
  bool pub_radar() const;
  void set_pub_radar(bool value);

  // optional bool pub_obu = 20 [default = false];
  bool has_pub_obu() const;
  void clear_pub_obu();
  static const int kPubObuFieldNumber = 20;
  bool pub_obu() const;
  void set_pub_obu(bool value);

  // optional bool use_falcon_lidar = 21 [default = true];
  bool has_use_falcon_lidar() const;
  void clear_use_falcon_lidar();
  static const int kUseFalconLidarFieldNumber = 21;
  bool use_falcon_lidar() const;
  void set_use_falcon_lidar(bool value);

  // optional double falcon_lidar_filter_distance = 22;
  bool has_falcon_lidar_filter_distance() const;
  void clear_falcon_lidar_filter_distance();
  static const int kFalconLidarFilterDistanceFieldNumber = 22;
  double falcon_lidar_filter_distance() const;
  void set_falcon_lidar_filter_distance(double value);

  // repeated .perception.VirtualObject virtual_object = 23;
  int virtual_object_size() const;
  void clear_virtual_object();
  static const int kVirtualObjectFieldNumber = 23;
  const ::perception::VirtualObject& virtual_object(int index) const;
  ::perception::VirtualObject* mutable_virtual_object(int index);
  ::perception::VirtualObject* add_virtual_object();
  ::google::protobuf::RepeatedPtrField< ::perception::VirtualObject >*
      mutable_virtual_object();
  const ::google::protobuf::RepeatedPtrField< ::perception::VirtualObject >&
      virtual_object() const;

  // @@protoc_insertion_point(class_scope:perception.FusionComponentInitOptions)
 private:
  inline void set_has_use_lidar();
  inline void clear_has_use_lidar();
  inline void set_has_use_radar();
  inline void clear_has_use_radar();
  inline void set_has_use_camera();
  inline void clear_has_use_camera();
  inline void set_has_fusion_method();
  inline void clear_has_fusion_method();
  inline void set_has_object_in_roi_check();
  inline void clear_has_object_in_roi_check();
  inline void set_has_radius_for_roi_object_check();
  inline void clear_has_radius_for_roi_object_check();
  inline void set_has_localization_topic();
  inline void clear_has_localization_topic();
  inline void set_has_output_obstacles_topic_name();
  inline void clear_has_output_obstacles_topic_name();
  inline void set_has_output_obstacles_topic_name_app();
  inline void clear_has_output_obstacles_topic_name_app();
  inline void set_has_output_viz_fused_box_topic_name();
  inline void clear_has_output_viz_fused_box_topic_name();
  inline void set_has_output_viz_fused_text_topic_name();
  inline void clear_has_output_viz_fused_text_topic_name();
  inline void set_has_enable_publish_fusion_topic();
  inline void clear_has_enable_publish_fusion_topic();
  inline void set_has_enable_publish_fusion_topic_app();
  inline void clear_has_enable_publish_fusion_topic_app();
  inline void set_has_use_obu();
  inline void clear_has_use_obu();
  inline void set_has_use_vidar();
  inline void clear_has_use_vidar();
  inline void set_has_pub_vidar();
  inline void clear_has_pub_vidar();
  inline void set_has_pub_radar();
  inline void clear_has_pub_radar();
  inline void set_has_pub_obu();
  inline void clear_has_pub_obu();
  inline void set_has_use_falcon_lidar();
  inline void clear_has_use_falcon_lidar();
  inline void set_has_falcon_lidar_filter_distance();
  inline void clear_has_falcon_lidar_filter_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perception::InputSensor > input_sensor_;
  ::google::protobuf::internal::ArenaStringPtr fusion_method_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fusion_main_sensors_;
  double radius_for_roi_object_check_;
  ::google::protobuf::internal::ArenaStringPtr localization_topic_;
  bool use_lidar_;
  bool use_radar_;
  bool use_camera_;
  bool object_in_roi_check_;
  bool enable_publish_fusion_topic_;
  bool enable_publish_fusion_topic_app_;
  bool use_obu_;
  bool use_vidar_;
  ::google::protobuf::internal::ArenaStringPtr output_obstacles_topic_name_;
  ::google::protobuf::internal::ArenaStringPtr output_obstacles_topic_name_app_;
  ::google::protobuf::internal::ArenaStringPtr output_viz_fused_box_topic_name_;
  ::google::protobuf::internal::ArenaStringPtr output_viz_fused_text_topic_name_;
  double falcon_lidar_filter_distance_;
  ::google::protobuf::RepeatedPtrField< ::perception::VirtualObject > virtual_object_;
  bool pub_vidar_;
  bool pub_radar_;
  bool pub_obu_;
  bool use_falcon_lidar_;
  friend void  protobuf_AddDesc_perception_5fcomponent_2eproto();
  friend void protobuf_AssignDesc_perception_5fcomponent_2eproto();
  friend void protobuf_ShutdownFile_perception_5fcomponent_2eproto();

  void InitAsDefaultInstance();
  static FusionComponentInitOptions* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Vector3

// optional double x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector3::x() const {
  // @@protoc_insertion_point(field_get:perception.Vector3.x)
  return x_;
}
inline void Vector3::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:perception.Vector3.x)
}

// optional double y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector3::y() const {
  // @@protoc_insertion_point(field_get:perception.Vector3.y)
  return y_;
}
inline void Vector3::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:perception.Vector3.y)
}

// optional double z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector3::z() const {
  // @@protoc_insertion_point(field_get:perception.Vector3.z)
  return z_;
}
inline void Vector3::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:perception.Vector3.z)
}

// -------------------------------------------------------------------

// Roi

// optional float roi_x_min = 1;
inline bool Roi::has_roi_x_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Roi::set_has_roi_x_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Roi::clear_has_roi_x_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Roi::clear_roi_x_min() {
  roi_x_min_ = 0;
  clear_has_roi_x_min();
}
inline float Roi::roi_x_min() const {
  // @@protoc_insertion_point(field_get:perception.Roi.roi_x_min)
  return roi_x_min_;
}
inline void Roi::set_roi_x_min(float value) {
  set_has_roi_x_min();
  roi_x_min_ = value;
  // @@protoc_insertion_point(field_set:perception.Roi.roi_x_min)
}

// optional float roi_x_max = 2;
inline bool Roi::has_roi_x_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Roi::set_has_roi_x_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Roi::clear_has_roi_x_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Roi::clear_roi_x_max() {
  roi_x_max_ = 0;
  clear_has_roi_x_max();
}
inline float Roi::roi_x_max() const {
  // @@protoc_insertion_point(field_get:perception.Roi.roi_x_max)
  return roi_x_max_;
}
inline void Roi::set_roi_x_max(float value) {
  set_has_roi_x_max();
  roi_x_max_ = value;
  // @@protoc_insertion_point(field_set:perception.Roi.roi_x_max)
}

// optional float roi_y_min = 3;
inline bool Roi::has_roi_y_min() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Roi::set_has_roi_y_min() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Roi::clear_has_roi_y_min() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Roi::clear_roi_y_min() {
  roi_y_min_ = 0;
  clear_has_roi_y_min();
}
inline float Roi::roi_y_min() const {
  // @@protoc_insertion_point(field_get:perception.Roi.roi_y_min)
  return roi_y_min_;
}
inline void Roi::set_roi_y_min(float value) {
  set_has_roi_y_min();
  roi_y_min_ = value;
  // @@protoc_insertion_point(field_set:perception.Roi.roi_y_min)
}

// optional float roi_y_max = 4;
inline bool Roi::has_roi_y_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Roi::set_has_roi_y_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Roi::clear_has_roi_y_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Roi::clear_roi_y_max() {
  roi_y_max_ = 0;
  clear_has_roi_y_max();
}
inline float Roi::roi_y_max() const {
  // @@protoc_insertion_point(field_get:perception.Roi.roi_y_max)
  return roi_y_max_;
}
inline void Roi::set_roi_y_max(float value) {
  set_has_roi_y_max();
  roi_y_max_ = value;
  // @@protoc_insertion_point(field_set:perception.Roi.roi_y_max)
}

// optional float roi_z_min = 5;
inline bool Roi::has_roi_z_min() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Roi::set_has_roi_z_min() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Roi::clear_has_roi_z_min() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Roi::clear_roi_z_min() {
  roi_z_min_ = 0;
  clear_has_roi_z_min();
}
inline float Roi::roi_z_min() const {
  // @@protoc_insertion_point(field_get:perception.Roi.roi_z_min)
  return roi_z_min_;
}
inline void Roi::set_roi_z_min(float value) {
  set_has_roi_z_min();
  roi_z_min_ = value;
  // @@protoc_insertion_point(field_set:perception.Roi.roi_z_min)
}

// optional float roi_z_max = 6;
inline bool Roi::has_roi_z_max() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Roi::set_has_roi_z_max() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Roi::clear_has_roi_z_max() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Roi::clear_roi_z_max() {
  roi_z_max_ = 0;
  clear_has_roi_z_max();
}
inline float Roi::roi_z_max() const {
  // @@protoc_insertion_point(field_get:perception.Roi.roi_z_max)
  return roi_z_max_;
}
inline void Roi::set_roi_z_max(float value) {
  set_has_roi_z_max();
  roi_z_max_ = value;
  // @@protoc_insertion_point(field_set:perception.Roi.roi_z_max)
}

// -------------------------------------------------------------------

// InputSensor

// optional string sensor_name = 1;
inline bool InputSensor::has_sensor_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputSensor::set_has_sensor_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputSensor::clear_has_sensor_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputSensor::clear_sensor_name() {
  sensor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sensor_name();
}
inline const ::std::string& InputSensor::sensor_name() const {
  // @@protoc_insertion_point(field_get:perception.InputSensor.sensor_name)
  return sensor_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputSensor::set_sensor_name(const ::std::string& value) {
  set_has_sensor_name();
  sensor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.InputSensor.sensor_name)
}
inline void InputSensor::set_sensor_name(const char* value) {
  set_has_sensor_name();
  sensor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.InputSensor.sensor_name)
}
inline void InputSensor::set_sensor_name(const char* value, size_t size) {
  set_has_sensor_name();
  sensor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.InputSensor.sensor_name)
}
inline ::std::string* InputSensor::mutable_sensor_name() {
  set_has_sensor_name();
  // @@protoc_insertion_point(field_mutable:perception.InputSensor.sensor_name)
  return sensor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputSensor::release_sensor_name() {
  // @@protoc_insertion_point(field_release:perception.InputSensor.sensor_name)
  clear_has_sensor_name();
  return sensor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputSensor::set_allocated_sensor_name(::std::string* sensor_name) {
  if (sensor_name != NULL) {
    set_has_sensor_name();
  } else {
    clear_has_sensor_name();
  }
  sensor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor_name);
  // @@protoc_insertion_point(field_set_allocated:perception.InputSensor.sensor_name)
}

// optional string topic = 2;
inline bool InputSensor::has_topic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputSensor::set_has_topic() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputSensor::clear_has_topic() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputSensor::clear_topic() {
  topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic();
}
inline const ::std::string& InputSensor::topic() const {
  // @@protoc_insertion_point(field_get:perception.InputSensor.topic)
  return topic_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputSensor::set_topic(const ::std::string& value) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.InputSensor.topic)
}
inline void InputSensor::set_topic(const char* value) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.InputSensor.topic)
}
inline void InputSensor::set_topic(const char* value, size_t size) {
  set_has_topic();
  topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.InputSensor.topic)
}
inline ::std::string* InputSensor::mutable_topic() {
  set_has_topic();
  // @@protoc_insertion_point(field_mutable:perception.InputSensor.topic)
  return topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputSensor::release_topic() {
  // @@protoc_insertion_point(field_release:perception.InputSensor.topic)
  clear_has_topic();
  return topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputSensor::set_allocated_topic(::std::string* topic) {
  if (topic != NULL) {
    set_has_topic();
  } else {
    clear_has_topic();
  }
  topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic);
  // @@protoc_insertion_point(field_set_allocated:perception.InputSensor.topic)
}

// -------------------------------------------------------------------

// LidarComponentInitOptions

// optional string input_sensor = 1;
inline bool LidarComponentInitOptions::has_input_sensor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LidarComponentInitOptions::set_has_input_sensor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LidarComponentInitOptions::clear_has_input_sensor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LidarComponentInitOptions::clear_input_sensor() {
  input_sensor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_input_sensor();
}
inline const ::std::string& LidarComponentInitOptions::input_sensor() const {
  // @@protoc_insertion_point(field_get:perception.LidarComponentInitOptions.input_sensor)
  return input_sensor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LidarComponentInitOptions::set_input_sensor(const ::std::string& value) {
  set_has_input_sensor();
  input_sensor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.LidarComponentInitOptions.input_sensor)
}
inline void LidarComponentInitOptions::set_input_sensor(const char* value) {
  set_has_input_sensor();
  input_sensor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.LidarComponentInitOptions.input_sensor)
}
inline void LidarComponentInitOptions::set_input_sensor(const char* value, size_t size) {
  set_has_input_sensor();
  input_sensor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.LidarComponentInitOptions.input_sensor)
}
inline ::std::string* LidarComponentInitOptions::mutable_input_sensor() {
  set_has_input_sensor();
  // @@protoc_insertion_point(field_mutable:perception.LidarComponentInitOptions.input_sensor)
  return input_sensor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LidarComponentInitOptions::release_input_sensor() {
  // @@protoc_insertion_point(field_release:perception.LidarComponentInitOptions.input_sensor)
  clear_has_input_sensor();
  return input_sensor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LidarComponentInitOptions::set_allocated_input_sensor(::std::string* input_sensor) {
  if (input_sensor != NULL) {
    set_has_input_sensor();
  } else {
    clear_has_input_sensor();
  }
  input_sensor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_sensor);
  // @@protoc_insertion_point(field_set_allocated:perception.LidarComponentInitOptions.input_sensor)
}

// optional .perception.Roi roi = 2;
inline bool LidarComponentInitOptions::has_roi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LidarComponentInitOptions::set_has_roi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LidarComponentInitOptions::clear_has_roi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LidarComponentInitOptions::clear_roi() {
  if (roi_ != NULL) roi_->::perception::Roi::Clear();
  clear_has_roi();
}
inline const ::perception::Roi& LidarComponentInitOptions::roi() const {
  // @@protoc_insertion_point(field_get:perception.LidarComponentInitOptions.roi)
  return roi_ != NULL ? *roi_ : *default_instance_->roi_;
}
inline ::perception::Roi* LidarComponentInitOptions::mutable_roi() {
  set_has_roi();
  if (roi_ == NULL) {
    roi_ = new ::perception::Roi;
  }
  // @@protoc_insertion_point(field_mutable:perception.LidarComponentInitOptions.roi)
  return roi_;
}
inline ::perception::Roi* LidarComponentInitOptions::release_roi() {
  // @@protoc_insertion_point(field_release:perception.LidarComponentInitOptions.roi)
  clear_has_roi();
  ::perception::Roi* temp = roi_;
  roi_ = NULL;
  return temp;
}
inline void LidarComponentInitOptions::set_allocated_roi(::perception::Roi* roi) {
  delete roi_;
  roi_ = roi;
  if (roi) {
    set_has_roi();
  } else {
    clear_has_roi();
  }
  // @@protoc_insertion_point(field_set_allocated:perception.LidarComponentInitOptions.roi)
}

// optional float sensor_height = 4;
inline bool LidarComponentInitOptions::has_sensor_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LidarComponentInitOptions::set_has_sensor_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LidarComponentInitOptions::clear_has_sensor_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LidarComponentInitOptions::clear_sensor_height() {
  sensor_height_ = 0;
  clear_has_sensor_height();
}
inline float LidarComponentInitOptions::sensor_height() const {
  // @@protoc_insertion_point(field_get:perception.LidarComponentInitOptions.sensor_height)
  return sensor_height_;
}
inline void LidarComponentInitOptions::set_sensor_height(float value) {
  set_has_sensor_height();
  sensor_height_ = value;
  // @@protoc_insertion_point(field_set:perception.LidarComponentInitOptions.sensor_height)
}

// optional float downsampling_radius = 5 [default = 0.06];
inline bool LidarComponentInitOptions::has_downsampling_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LidarComponentInitOptions::set_has_downsampling_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LidarComponentInitOptions::clear_has_downsampling_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LidarComponentInitOptions::clear_downsampling_radius() {
  downsampling_radius_ = 0.06f;
  clear_has_downsampling_radius();
}
inline float LidarComponentInitOptions::downsampling_radius() const {
  // @@protoc_insertion_point(field_get:perception.LidarComponentInitOptions.downsampling_radius)
  return downsampling_radius_;
}
inline void LidarComponentInitOptions::set_downsampling_radius(float value) {
  set_has_downsampling_radius();
  downsampling_radius_ = value;
  // @@protoc_insertion_point(field_set:perception.LidarComponentInitOptions.downsampling_radius)
}

// optional int32 num_lpr = 6;
inline bool LidarComponentInitOptions::has_num_lpr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LidarComponentInitOptions::set_has_num_lpr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LidarComponentInitOptions::clear_has_num_lpr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LidarComponentInitOptions::clear_num_lpr() {
  num_lpr_ = 0;
  clear_has_num_lpr();
}
inline ::google::protobuf::int32 LidarComponentInitOptions::num_lpr() const {
  // @@protoc_insertion_point(field_get:perception.LidarComponentInitOptions.num_lpr)
  return num_lpr_;
}
inline void LidarComponentInitOptions::set_num_lpr(::google::protobuf::int32 value) {
  set_has_num_lpr();
  num_lpr_ = value;
  // @@protoc_insertion_point(field_set:perception.LidarComponentInitOptions.num_lpr)
}

// optional float th_dist = 7;
inline bool LidarComponentInitOptions::has_th_dist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LidarComponentInitOptions::set_has_th_dist() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LidarComponentInitOptions::clear_has_th_dist() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LidarComponentInitOptions::clear_th_dist() {
  th_dist_ = 0;
  clear_has_th_dist();
}
inline float LidarComponentInitOptions::th_dist() const {
  // @@protoc_insertion_point(field_get:perception.LidarComponentInitOptions.th_dist)
  return th_dist_;
}
inline void LidarComponentInitOptions::set_th_dist(float value) {
  set_has_th_dist();
  th_dist_ = value;
  // @@protoc_insertion_point(field_set:perception.LidarComponentInitOptions.th_dist)
}

// optional float th_seeds = 8;
inline bool LidarComponentInitOptions::has_th_seeds() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LidarComponentInitOptions::set_has_th_seeds() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LidarComponentInitOptions::clear_has_th_seeds() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LidarComponentInitOptions::clear_th_seeds() {
  th_seeds_ = 0;
  clear_has_th_seeds();
}
inline float LidarComponentInitOptions::th_seeds() const {
  // @@protoc_insertion_point(field_get:perception.LidarComponentInitOptions.th_seeds)
  return th_seeds_;
}
inline void LidarComponentInitOptions::set_th_seeds(float value) {
  set_has_th_seeds();
  th_seeds_ = value;
  // @@protoc_insertion_point(field_set:perception.LidarComponentInitOptions.th_seeds)
}

// optional float min_distance = 9;
inline bool LidarComponentInitOptions::has_min_distance() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LidarComponentInitOptions::set_has_min_distance() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LidarComponentInitOptions::clear_has_min_distance() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LidarComponentInitOptions::clear_min_distance() {
  min_distance_ = 0;
  clear_has_min_distance();
}
inline float LidarComponentInitOptions::min_distance() const {
  // @@protoc_insertion_point(field_get:perception.LidarComponentInitOptions.min_distance)
  return min_distance_;
}
inline void LidarComponentInitOptions::set_min_distance(float value) {
  set_has_min_distance();
  min_distance_ = value;
  // @@protoc_insertion_point(field_set:perception.LidarComponentInitOptions.min_distance)
}

// optional bool publish_cluster = 10 [default = false];
inline bool LidarComponentInitOptions::has_publish_cluster() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LidarComponentInitOptions::set_has_publish_cluster() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LidarComponentInitOptions::clear_has_publish_cluster() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LidarComponentInitOptions::clear_publish_cluster() {
  publish_cluster_ = false;
  clear_has_publish_cluster();
}
inline bool LidarComponentInitOptions::publish_cluster() const {
  // @@protoc_insertion_point(field_get:perception.LidarComponentInitOptions.publish_cluster)
  return publish_cluster_;
}
inline void LidarComponentInitOptions::set_publish_cluster(bool value) {
  set_has_publish_cluster();
  publish_cluster_ = value;
  // @@protoc_insertion_point(field_set:perception.LidarComponentInitOptions.publish_cluster)
}

// -------------------------------------------------------------------

// CameraComponentInitOptions

// optional string input_sensor = 1;
inline bool CameraComponentInitOptions::has_input_sensor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraComponentInitOptions::set_has_input_sensor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraComponentInitOptions::clear_has_input_sensor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraComponentInitOptions::clear_input_sensor() {
  input_sensor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_input_sensor();
}
inline const ::std::string& CameraComponentInitOptions::input_sensor() const {
  // @@protoc_insertion_point(field_get:perception.CameraComponentInitOptions.input_sensor)
  return input_sensor_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraComponentInitOptions::set_input_sensor(const ::std::string& value) {
  set_has_input_sensor();
  input_sensor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.CameraComponentInitOptions.input_sensor)
}
inline void CameraComponentInitOptions::set_input_sensor(const char* value) {
  set_has_input_sensor();
  input_sensor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.CameraComponentInitOptions.input_sensor)
}
inline void CameraComponentInitOptions::set_input_sensor(const char* value, size_t size) {
  set_has_input_sensor();
  input_sensor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.CameraComponentInitOptions.input_sensor)
}
inline ::std::string* CameraComponentInitOptions::mutable_input_sensor() {
  set_has_input_sensor();
  // @@protoc_insertion_point(field_mutable:perception.CameraComponentInitOptions.input_sensor)
  return input_sensor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CameraComponentInitOptions::release_input_sensor() {
  // @@protoc_insertion_point(field_release:perception.CameraComponentInitOptions.input_sensor)
  clear_has_input_sensor();
  return input_sensor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraComponentInitOptions::set_allocated_input_sensor(::std::string* input_sensor) {
  if (input_sensor != NULL) {
    set_has_input_sensor();
  } else {
    clear_has_input_sensor();
  }
  input_sensor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), input_sensor);
  // @@protoc_insertion_point(field_set_allocated:perception.CameraComponentInitOptions.input_sensor)
}

// optional string load_serialize_path = 2 [deprecated = true];
inline bool CameraComponentInitOptions::has_load_serialize_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraComponentInitOptions::set_has_load_serialize_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraComponentInitOptions::clear_has_load_serialize_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraComponentInitOptions::clear_load_serialize_path() {
  load_serialize_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_load_serialize_path();
}
inline const ::std::string& CameraComponentInitOptions::load_serialize_path() const {
  // @@protoc_insertion_point(field_get:perception.CameraComponentInitOptions.load_serialize_path)
  return load_serialize_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraComponentInitOptions::set_load_serialize_path(const ::std::string& value) {
  set_has_load_serialize_path();
  load_serialize_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.CameraComponentInitOptions.load_serialize_path)
}
inline void CameraComponentInitOptions::set_load_serialize_path(const char* value) {
  set_has_load_serialize_path();
  load_serialize_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.CameraComponentInitOptions.load_serialize_path)
}
inline void CameraComponentInitOptions::set_load_serialize_path(const char* value, size_t size) {
  set_has_load_serialize_path();
  load_serialize_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.CameraComponentInitOptions.load_serialize_path)
}
inline ::std::string* CameraComponentInitOptions::mutable_load_serialize_path() {
  set_has_load_serialize_path();
  // @@protoc_insertion_point(field_mutable:perception.CameraComponentInitOptions.load_serialize_path)
  return load_serialize_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CameraComponentInitOptions::release_load_serialize_path() {
  // @@protoc_insertion_point(field_release:perception.CameraComponentInitOptions.load_serialize_path)
  clear_has_load_serialize_path();
  return load_serialize_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraComponentInitOptions::set_allocated_load_serialize_path(::std::string* load_serialize_path) {
  if (load_serialize_path != NULL) {
    set_has_load_serialize_path();
  } else {
    clear_has_load_serialize_path();
  }
  load_serialize_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), load_serialize_path);
  // @@protoc_insertion_point(field_set_allocated:perception.CameraComponentInitOptions.load_serialize_path)
}

// optional string load_class_names = 3 [deprecated = true];
inline bool CameraComponentInitOptions::has_load_class_names() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraComponentInitOptions::set_has_load_class_names() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraComponentInitOptions::clear_has_load_class_names() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraComponentInitOptions::clear_load_class_names() {
  load_class_names_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_load_class_names();
}
inline const ::std::string& CameraComponentInitOptions::load_class_names() const {
  // @@protoc_insertion_point(field_get:perception.CameraComponentInitOptions.load_class_names)
  return load_class_names_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraComponentInitOptions::set_load_class_names(const ::std::string& value) {
  set_has_load_class_names();
  load_class_names_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.CameraComponentInitOptions.load_class_names)
}
inline void CameraComponentInitOptions::set_load_class_names(const char* value) {
  set_has_load_class_names();
  load_class_names_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.CameraComponentInitOptions.load_class_names)
}
inline void CameraComponentInitOptions::set_load_class_names(const char* value, size_t size) {
  set_has_load_class_names();
  load_class_names_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.CameraComponentInitOptions.load_class_names)
}
inline ::std::string* CameraComponentInitOptions::mutable_load_class_names() {
  set_has_load_class_names();
  // @@protoc_insertion_point(field_mutable:perception.CameraComponentInitOptions.load_class_names)
  return load_class_names_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CameraComponentInitOptions::release_load_class_names() {
  // @@protoc_insertion_point(field_release:perception.CameraComponentInitOptions.load_class_names)
  clear_has_load_class_names();
  return load_class_names_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraComponentInitOptions::set_allocated_load_class_names(::std::string* load_class_names) {
  if (load_class_names != NULL) {
    set_has_load_class_names();
  } else {
    clear_has_load_class_names();
  }
  load_class_names_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), load_class_names);
  // @@protoc_insertion_point(field_set_allocated:perception.CameraComponentInitOptions.load_class_names)
}

// optional string publish_objects = 6;
inline bool CameraComponentInitOptions::has_publish_objects() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraComponentInitOptions::set_has_publish_objects() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraComponentInitOptions::clear_has_publish_objects() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraComponentInitOptions::clear_publish_objects() {
  publish_objects_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_publish_objects();
}
inline const ::std::string& CameraComponentInitOptions::publish_objects() const {
  // @@protoc_insertion_point(field_get:perception.CameraComponentInitOptions.publish_objects)
  return publish_objects_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraComponentInitOptions::set_publish_objects(const ::std::string& value) {
  set_has_publish_objects();
  publish_objects_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.CameraComponentInitOptions.publish_objects)
}
inline void CameraComponentInitOptions::set_publish_objects(const char* value) {
  set_has_publish_objects();
  publish_objects_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.CameraComponentInitOptions.publish_objects)
}
inline void CameraComponentInitOptions::set_publish_objects(const char* value, size_t size) {
  set_has_publish_objects();
  publish_objects_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.CameraComponentInitOptions.publish_objects)
}
inline ::std::string* CameraComponentInitOptions::mutable_publish_objects() {
  set_has_publish_objects();
  // @@protoc_insertion_point(field_mutable:perception.CameraComponentInitOptions.publish_objects)
  return publish_objects_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CameraComponentInitOptions::release_publish_objects() {
  // @@protoc_insertion_point(field_release:perception.CameraComponentInitOptions.publish_objects)
  clear_has_publish_objects();
  return publish_objects_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CameraComponentInitOptions::set_allocated_publish_objects(::std::string* publish_objects) {
  if (publish_objects != NULL) {
    set_has_publish_objects();
  } else {
    clear_has_publish_objects();
  }
  publish_objects_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), publish_objects);
  // @@protoc_insertion_point(field_set_allocated:perception.CameraComponentInitOptions.publish_objects)
}

// -------------------------------------------------------------------

// VirtualObject

// optional uint32 id = 1;
inline bool VirtualObject::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VirtualObject::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VirtualObject::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VirtualObject::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 VirtualObject::id() const {
  // @@protoc_insertion_point(field_get:perception.VirtualObject.id)
  return id_;
}
inline void VirtualObject::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:perception.VirtualObject.id)
}

// optional .perception.Vector3 position = 2;
inline bool VirtualObject::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VirtualObject::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VirtualObject::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VirtualObject::clear_position() {
  if (position_ != NULL) position_->::perception::Vector3::Clear();
  clear_has_position();
}
inline const ::perception::Vector3& VirtualObject::position() const {
  // @@protoc_insertion_point(field_get:perception.VirtualObject.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::perception::Vector3* VirtualObject::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::perception::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:perception.VirtualObject.position)
  return position_;
}
inline ::perception::Vector3* VirtualObject::release_position() {
  // @@protoc_insertion_point(field_release:perception.VirtualObject.position)
  clear_has_position();
  ::perception::Vector3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void VirtualObject::set_allocated_position(::perception::Vector3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:perception.VirtualObject.position)
}

// optional .perception.Vector3 size = 3;
inline bool VirtualObject::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VirtualObject::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VirtualObject::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VirtualObject::clear_size() {
  if (size_ != NULL) size_->::perception::Vector3::Clear();
  clear_has_size();
}
inline const ::perception::Vector3& VirtualObject::size() const {
  // @@protoc_insertion_point(field_get:perception.VirtualObject.size)
  return size_ != NULL ? *size_ : *default_instance_->size_;
}
inline ::perception::Vector3* VirtualObject::mutable_size() {
  set_has_size();
  if (size_ == NULL) {
    size_ = new ::perception::Vector3;
  }
  // @@protoc_insertion_point(field_mutable:perception.VirtualObject.size)
  return size_;
}
inline ::perception::Vector3* VirtualObject::release_size() {
  // @@protoc_insertion_point(field_release:perception.VirtualObject.size)
  clear_has_size();
  ::perception::Vector3* temp = size_;
  size_ = NULL;
  return temp;
}
inline void VirtualObject::set_allocated_size(::perception::Vector3* size) {
  delete size_;
  size_ = size;
  if (size) {
    set_has_size();
  } else {
    clear_has_size();
  }
  // @@protoc_insertion_point(field_set_allocated:perception.VirtualObject.size)
}

// optional double yaw = 4;
inline bool VirtualObject::has_yaw() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VirtualObject::set_has_yaw() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VirtualObject::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VirtualObject::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline double VirtualObject::yaw() const {
  // @@protoc_insertion_point(field_get:perception.VirtualObject.yaw)
  return yaw_;
}
inline void VirtualObject::set_yaw(double value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:perception.VirtualObject.yaw)
}

// -------------------------------------------------------------------

// FusionComponentInitOptions

// optional bool use_lidar = 1 [default = true];
inline bool FusionComponentInitOptions::has_use_lidar() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FusionComponentInitOptions::set_has_use_lidar() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FusionComponentInitOptions::clear_has_use_lidar() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FusionComponentInitOptions::clear_use_lidar() {
  use_lidar_ = true;
  clear_has_use_lidar();
}
inline bool FusionComponentInitOptions::use_lidar() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.use_lidar)
  return use_lidar_;
}
inline void FusionComponentInitOptions::set_use_lidar(bool value) {
  set_has_use_lidar();
  use_lidar_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.use_lidar)
}

// optional bool use_radar = 2 [default = false];
inline bool FusionComponentInitOptions::has_use_radar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FusionComponentInitOptions::set_has_use_radar() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FusionComponentInitOptions::clear_has_use_radar() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FusionComponentInitOptions::clear_use_radar() {
  use_radar_ = false;
  clear_has_use_radar();
}
inline bool FusionComponentInitOptions::use_radar() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.use_radar)
  return use_radar_;
}
inline void FusionComponentInitOptions::set_use_radar(bool value) {
  set_has_use_radar();
  use_radar_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.use_radar)
}

// optional bool use_camera = 3 [default = true];
inline bool FusionComponentInitOptions::has_use_camera() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FusionComponentInitOptions::set_has_use_camera() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FusionComponentInitOptions::clear_has_use_camera() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FusionComponentInitOptions::clear_use_camera() {
  use_camera_ = true;
  clear_has_use_camera();
}
inline bool FusionComponentInitOptions::use_camera() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.use_camera)
  return use_camera_;
}
inline void FusionComponentInitOptions::set_use_camera(bool value) {
  set_has_use_camera();
  use_camera_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.use_camera)
}

// repeated .perception.InputSensor input_sensor = 4;
inline int FusionComponentInitOptions::input_sensor_size() const {
  return input_sensor_.size();
}
inline void FusionComponentInitOptions::clear_input_sensor() {
  input_sensor_.Clear();
}
inline const ::perception::InputSensor& FusionComponentInitOptions::input_sensor(int index) const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.input_sensor)
  return input_sensor_.Get(index);
}
inline ::perception::InputSensor* FusionComponentInitOptions::mutable_input_sensor(int index) {
  // @@protoc_insertion_point(field_mutable:perception.FusionComponentInitOptions.input_sensor)
  return input_sensor_.Mutable(index);
}
inline ::perception::InputSensor* FusionComponentInitOptions::add_input_sensor() {
  // @@protoc_insertion_point(field_add:perception.FusionComponentInitOptions.input_sensor)
  return input_sensor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perception::InputSensor >*
FusionComponentInitOptions::mutable_input_sensor() {
  // @@protoc_insertion_point(field_mutable_list:perception.FusionComponentInitOptions.input_sensor)
  return &input_sensor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perception::InputSensor >&
FusionComponentInitOptions::input_sensor() const {
  // @@protoc_insertion_point(field_list:perception.FusionComponentInitOptions.input_sensor)
  return input_sensor_;
}

// optional string fusion_method = 5;
inline bool FusionComponentInitOptions::has_fusion_method() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FusionComponentInitOptions::set_has_fusion_method() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FusionComponentInitOptions::clear_has_fusion_method() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FusionComponentInitOptions::clear_fusion_method() {
  fusion_method_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fusion_method();
}
inline const ::std::string& FusionComponentInitOptions::fusion_method() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.fusion_method)
  return fusion_method_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_fusion_method(const ::std::string& value) {
  set_has_fusion_method();
  fusion_method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.fusion_method)
}
inline void FusionComponentInitOptions::set_fusion_method(const char* value) {
  set_has_fusion_method();
  fusion_method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.FusionComponentInitOptions.fusion_method)
}
inline void FusionComponentInitOptions::set_fusion_method(const char* value, size_t size) {
  set_has_fusion_method();
  fusion_method_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.FusionComponentInitOptions.fusion_method)
}
inline ::std::string* FusionComponentInitOptions::mutable_fusion_method() {
  set_has_fusion_method();
  // @@protoc_insertion_point(field_mutable:perception.FusionComponentInitOptions.fusion_method)
  return fusion_method_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FusionComponentInitOptions::release_fusion_method() {
  // @@protoc_insertion_point(field_release:perception.FusionComponentInitOptions.fusion_method)
  clear_has_fusion_method();
  return fusion_method_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_allocated_fusion_method(::std::string* fusion_method) {
  if (fusion_method != NULL) {
    set_has_fusion_method();
  } else {
    clear_has_fusion_method();
  }
  fusion_method_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fusion_method);
  // @@protoc_insertion_point(field_set_allocated:perception.FusionComponentInitOptions.fusion_method)
}

// repeated string fusion_main_sensors = 6;
inline int FusionComponentInitOptions::fusion_main_sensors_size() const {
  return fusion_main_sensors_.size();
}
inline void FusionComponentInitOptions::clear_fusion_main_sensors() {
  fusion_main_sensors_.Clear();
}
inline const ::std::string& FusionComponentInitOptions::fusion_main_sensors(int index) const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.fusion_main_sensors)
  return fusion_main_sensors_.Get(index);
}
inline ::std::string* FusionComponentInitOptions::mutable_fusion_main_sensors(int index) {
  // @@protoc_insertion_point(field_mutable:perception.FusionComponentInitOptions.fusion_main_sensors)
  return fusion_main_sensors_.Mutable(index);
}
inline void FusionComponentInitOptions::set_fusion_main_sensors(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.fusion_main_sensors)
  fusion_main_sensors_.Mutable(index)->assign(value);
}
inline void FusionComponentInitOptions::set_fusion_main_sensors(int index, const char* value) {
  fusion_main_sensors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perception.FusionComponentInitOptions.fusion_main_sensors)
}
inline void FusionComponentInitOptions::set_fusion_main_sensors(int index, const char* value, size_t size) {
  fusion_main_sensors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perception.FusionComponentInitOptions.fusion_main_sensors)
}
inline ::std::string* FusionComponentInitOptions::add_fusion_main_sensors() {
  // @@protoc_insertion_point(field_add_mutable:perception.FusionComponentInitOptions.fusion_main_sensors)
  return fusion_main_sensors_.Add();
}
inline void FusionComponentInitOptions::add_fusion_main_sensors(const ::std::string& value) {
  fusion_main_sensors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perception.FusionComponentInitOptions.fusion_main_sensors)
}
inline void FusionComponentInitOptions::add_fusion_main_sensors(const char* value) {
  fusion_main_sensors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perception.FusionComponentInitOptions.fusion_main_sensors)
}
inline void FusionComponentInitOptions::add_fusion_main_sensors(const char* value, size_t size) {
  fusion_main_sensors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perception.FusionComponentInitOptions.fusion_main_sensors)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FusionComponentInitOptions::fusion_main_sensors() const {
  // @@protoc_insertion_point(field_list:perception.FusionComponentInitOptions.fusion_main_sensors)
  return fusion_main_sensors_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FusionComponentInitOptions::mutable_fusion_main_sensors() {
  // @@protoc_insertion_point(field_mutable_list:perception.FusionComponentInitOptions.fusion_main_sensors)
  return &fusion_main_sensors_;
}

// optional bool object_in_roi_check = 7;
inline bool FusionComponentInitOptions::has_object_in_roi_check() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FusionComponentInitOptions::set_has_object_in_roi_check() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FusionComponentInitOptions::clear_has_object_in_roi_check() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FusionComponentInitOptions::clear_object_in_roi_check() {
  object_in_roi_check_ = false;
  clear_has_object_in_roi_check();
}
inline bool FusionComponentInitOptions::object_in_roi_check() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.object_in_roi_check)
  return object_in_roi_check_;
}
inline void FusionComponentInitOptions::set_object_in_roi_check(bool value) {
  set_has_object_in_roi_check();
  object_in_roi_check_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.object_in_roi_check)
}

// optional double radius_for_roi_object_check = 8;
inline bool FusionComponentInitOptions::has_radius_for_roi_object_check() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FusionComponentInitOptions::set_has_radius_for_roi_object_check() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FusionComponentInitOptions::clear_has_radius_for_roi_object_check() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FusionComponentInitOptions::clear_radius_for_roi_object_check() {
  radius_for_roi_object_check_ = 0;
  clear_has_radius_for_roi_object_check();
}
inline double FusionComponentInitOptions::radius_for_roi_object_check() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.radius_for_roi_object_check)
  return radius_for_roi_object_check_;
}
inline void FusionComponentInitOptions::set_radius_for_roi_object_check(double value) {
  set_has_radius_for_roi_object_check();
  radius_for_roi_object_check_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.radius_for_roi_object_check)
}

// optional string localization_topic = 9;
inline bool FusionComponentInitOptions::has_localization_topic() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FusionComponentInitOptions::set_has_localization_topic() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FusionComponentInitOptions::clear_has_localization_topic() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FusionComponentInitOptions::clear_localization_topic() {
  localization_topic_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_localization_topic();
}
inline const ::std::string& FusionComponentInitOptions::localization_topic() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.localization_topic)
  return localization_topic_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_localization_topic(const ::std::string& value) {
  set_has_localization_topic();
  localization_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.localization_topic)
}
inline void FusionComponentInitOptions::set_localization_topic(const char* value) {
  set_has_localization_topic();
  localization_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.FusionComponentInitOptions.localization_topic)
}
inline void FusionComponentInitOptions::set_localization_topic(const char* value, size_t size) {
  set_has_localization_topic();
  localization_topic_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.FusionComponentInitOptions.localization_topic)
}
inline ::std::string* FusionComponentInitOptions::mutable_localization_topic() {
  set_has_localization_topic();
  // @@protoc_insertion_point(field_mutable:perception.FusionComponentInitOptions.localization_topic)
  return localization_topic_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FusionComponentInitOptions::release_localization_topic() {
  // @@protoc_insertion_point(field_release:perception.FusionComponentInitOptions.localization_topic)
  clear_has_localization_topic();
  return localization_topic_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_allocated_localization_topic(::std::string* localization_topic) {
  if (localization_topic != NULL) {
    set_has_localization_topic();
  } else {
    clear_has_localization_topic();
  }
  localization_topic_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), localization_topic);
  // @@protoc_insertion_point(field_set_allocated:perception.FusionComponentInitOptions.localization_topic)
}

// optional string output_obstacles_topic_name = 10;
inline bool FusionComponentInitOptions::has_output_obstacles_topic_name() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FusionComponentInitOptions::set_has_output_obstacles_topic_name() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FusionComponentInitOptions::clear_has_output_obstacles_topic_name() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FusionComponentInitOptions::clear_output_obstacles_topic_name() {
  output_obstacles_topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_output_obstacles_topic_name();
}
inline const ::std::string& FusionComponentInitOptions::output_obstacles_topic_name() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.output_obstacles_topic_name)
  return output_obstacles_topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_output_obstacles_topic_name(const ::std::string& value) {
  set_has_output_obstacles_topic_name();
  output_obstacles_topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.output_obstacles_topic_name)
}
inline void FusionComponentInitOptions::set_output_obstacles_topic_name(const char* value) {
  set_has_output_obstacles_topic_name();
  output_obstacles_topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.FusionComponentInitOptions.output_obstacles_topic_name)
}
inline void FusionComponentInitOptions::set_output_obstacles_topic_name(const char* value, size_t size) {
  set_has_output_obstacles_topic_name();
  output_obstacles_topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.FusionComponentInitOptions.output_obstacles_topic_name)
}
inline ::std::string* FusionComponentInitOptions::mutable_output_obstacles_topic_name() {
  set_has_output_obstacles_topic_name();
  // @@protoc_insertion_point(field_mutable:perception.FusionComponentInitOptions.output_obstacles_topic_name)
  return output_obstacles_topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FusionComponentInitOptions::release_output_obstacles_topic_name() {
  // @@protoc_insertion_point(field_release:perception.FusionComponentInitOptions.output_obstacles_topic_name)
  clear_has_output_obstacles_topic_name();
  return output_obstacles_topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_allocated_output_obstacles_topic_name(::std::string* output_obstacles_topic_name) {
  if (output_obstacles_topic_name != NULL) {
    set_has_output_obstacles_topic_name();
  } else {
    clear_has_output_obstacles_topic_name();
  }
  output_obstacles_topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_obstacles_topic_name);
  // @@protoc_insertion_point(field_set_allocated:perception.FusionComponentInitOptions.output_obstacles_topic_name)
}

// optional string output_obstacles_topic_name_app = 11;
inline bool FusionComponentInitOptions::has_output_obstacles_topic_name_app() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FusionComponentInitOptions::set_has_output_obstacles_topic_name_app() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FusionComponentInitOptions::clear_has_output_obstacles_topic_name_app() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FusionComponentInitOptions::clear_output_obstacles_topic_name_app() {
  output_obstacles_topic_name_app_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_output_obstacles_topic_name_app();
}
inline const ::std::string& FusionComponentInitOptions::output_obstacles_topic_name_app() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.output_obstacles_topic_name_app)
  return output_obstacles_topic_name_app_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_output_obstacles_topic_name_app(const ::std::string& value) {
  set_has_output_obstacles_topic_name_app();
  output_obstacles_topic_name_app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.output_obstacles_topic_name_app)
}
inline void FusionComponentInitOptions::set_output_obstacles_topic_name_app(const char* value) {
  set_has_output_obstacles_topic_name_app();
  output_obstacles_topic_name_app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.FusionComponentInitOptions.output_obstacles_topic_name_app)
}
inline void FusionComponentInitOptions::set_output_obstacles_topic_name_app(const char* value, size_t size) {
  set_has_output_obstacles_topic_name_app();
  output_obstacles_topic_name_app_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.FusionComponentInitOptions.output_obstacles_topic_name_app)
}
inline ::std::string* FusionComponentInitOptions::mutable_output_obstacles_topic_name_app() {
  set_has_output_obstacles_topic_name_app();
  // @@protoc_insertion_point(field_mutable:perception.FusionComponentInitOptions.output_obstacles_topic_name_app)
  return output_obstacles_topic_name_app_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FusionComponentInitOptions::release_output_obstacles_topic_name_app() {
  // @@protoc_insertion_point(field_release:perception.FusionComponentInitOptions.output_obstacles_topic_name_app)
  clear_has_output_obstacles_topic_name_app();
  return output_obstacles_topic_name_app_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_allocated_output_obstacles_topic_name_app(::std::string* output_obstacles_topic_name_app) {
  if (output_obstacles_topic_name_app != NULL) {
    set_has_output_obstacles_topic_name_app();
  } else {
    clear_has_output_obstacles_topic_name_app();
  }
  output_obstacles_topic_name_app_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_obstacles_topic_name_app);
  // @@protoc_insertion_point(field_set_allocated:perception.FusionComponentInitOptions.output_obstacles_topic_name_app)
}

// optional string output_viz_fused_box_topic_name = 12;
inline bool FusionComponentInitOptions::has_output_viz_fused_box_topic_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FusionComponentInitOptions::set_has_output_viz_fused_box_topic_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FusionComponentInitOptions::clear_has_output_viz_fused_box_topic_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FusionComponentInitOptions::clear_output_viz_fused_box_topic_name() {
  output_viz_fused_box_topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_output_viz_fused_box_topic_name();
}
inline const ::std::string& FusionComponentInitOptions::output_viz_fused_box_topic_name() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.output_viz_fused_box_topic_name)
  return output_viz_fused_box_topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_output_viz_fused_box_topic_name(const ::std::string& value) {
  set_has_output_viz_fused_box_topic_name();
  output_viz_fused_box_topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.output_viz_fused_box_topic_name)
}
inline void FusionComponentInitOptions::set_output_viz_fused_box_topic_name(const char* value) {
  set_has_output_viz_fused_box_topic_name();
  output_viz_fused_box_topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.FusionComponentInitOptions.output_viz_fused_box_topic_name)
}
inline void FusionComponentInitOptions::set_output_viz_fused_box_topic_name(const char* value, size_t size) {
  set_has_output_viz_fused_box_topic_name();
  output_viz_fused_box_topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.FusionComponentInitOptions.output_viz_fused_box_topic_name)
}
inline ::std::string* FusionComponentInitOptions::mutable_output_viz_fused_box_topic_name() {
  set_has_output_viz_fused_box_topic_name();
  // @@protoc_insertion_point(field_mutable:perception.FusionComponentInitOptions.output_viz_fused_box_topic_name)
  return output_viz_fused_box_topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FusionComponentInitOptions::release_output_viz_fused_box_topic_name() {
  // @@protoc_insertion_point(field_release:perception.FusionComponentInitOptions.output_viz_fused_box_topic_name)
  clear_has_output_viz_fused_box_topic_name();
  return output_viz_fused_box_topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_allocated_output_viz_fused_box_topic_name(::std::string* output_viz_fused_box_topic_name) {
  if (output_viz_fused_box_topic_name != NULL) {
    set_has_output_viz_fused_box_topic_name();
  } else {
    clear_has_output_viz_fused_box_topic_name();
  }
  output_viz_fused_box_topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_viz_fused_box_topic_name);
  // @@protoc_insertion_point(field_set_allocated:perception.FusionComponentInitOptions.output_viz_fused_box_topic_name)
}

// optional string output_viz_fused_text_topic_name = 13;
inline bool FusionComponentInitOptions::has_output_viz_fused_text_topic_name() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FusionComponentInitOptions::set_has_output_viz_fused_text_topic_name() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FusionComponentInitOptions::clear_has_output_viz_fused_text_topic_name() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FusionComponentInitOptions::clear_output_viz_fused_text_topic_name() {
  output_viz_fused_text_topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_output_viz_fused_text_topic_name();
}
inline const ::std::string& FusionComponentInitOptions::output_viz_fused_text_topic_name() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.output_viz_fused_text_topic_name)
  return output_viz_fused_text_topic_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_output_viz_fused_text_topic_name(const ::std::string& value) {
  set_has_output_viz_fused_text_topic_name();
  output_viz_fused_text_topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.output_viz_fused_text_topic_name)
}
inline void FusionComponentInitOptions::set_output_viz_fused_text_topic_name(const char* value) {
  set_has_output_viz_fused_text_topic_name();
  output_viz_fused_text_topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perception.FusionComponentInitOptions.output_viz_fused_text_topic_name)
}
inline void FusionComponentInitOptions::set_output_viz_fused_text_topic_name(const char* value, size_t size) {
  set_has_output_viz_fused_text_topic_name();
  output_viz_fused_text_topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perception.FusionComponentInitOptions.output_viz_fused_text_topic_name)
}
inline ::std::string* FusionComponentInitOptions::mutable_output_viz_fused_text_topic_name() {
  set_has_output_viz_fused_text_topic_name();
  // @@protoc_insertion_point(field_mutable:perception.FusionComponentInitOptions.output_viz_fused_text_topic_name)
  return output_viz_fused_text_topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FusionComponentInitOptions::release_output_viz_fused_text_topic_name() {
  // @@protoc_insertion_point(field_release:perception.FusionComponentInitOptions.output_viz_fused_text_topic_name)
  clear_has_output_viz_fused_text_topic_name();
  return output_viz_fused_text_topic_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionComponentInitOptions::set_allocated_output_viz_fused_text_topic_name(::std::string* output_viz_fused_text_topic_name) {
  if (output_viz_fused_text_topic_name != NULL) {
    set_has_output_viz_fused_text_topic_name();
  } else {
    clear_has_output_viz_fused_text_topic_name();
  }
  output_viz_fused_text_topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_viz_fused_text_topic_name);
  // @@protoc_insertion_point(field_set_allocated:perception.FusionComponentInitOptions.output_viz_fused_text_topic_name)
}

// optional bool enable_publish_fusion_topic = 14 [default = true];
inline bool FusionComponentInitOptions::has_enable_publish_fusion_topic() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FusionComponentInitOptions::set_has_enable_publish_fusion_topic() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FusionComponentInitOptions::clear_has_enable_publish_fusion_topic() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FusionComponentInitOptions::clear_enable_publish_fusion_topic() {
  enable_publish_fusion_topic_ = true;
  clear_has_enable_publish_fusion_topic();
}
inline bool FusionComponentInitOptions::enable_publish_fusion_topic() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.enable_publish_fusion_topic)
  return enable_publish_fusion_topic_;
}
inline void FusionComponentInitOptions::set_enable_publish_fusion_topic(bool value) {
  set_has_enable_publish_fusion_topic();
  enable_publish_fusion_topic_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.enable_publish_fusion_topic)
}

// optional bool enable_publish_fusion_topic_app = 15 [default = true];
inline bool FusionComponentInitOptions::has_enable_publish_fusion_topic_app() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void FusionComponentInitOptions::set_has_enable_publish_fusion_topic_app() {
  _has_bits_[0] |= 0x00004000u;
}
inline void FusionComponentInitOptions::clear_has_enable_publish_fusion_topic_app() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void FusionComponentInitOptions::clear_enable_publish_fusion_topic_app() {
  enable_publish_fusion_topic_app_ = true;
  clear_has_enable_publish_fusion_topic_app();
}
inline bool FusionComponentInitOptions::enable_publish_fusion_topic_app() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.enable_publish_fusion_topic_app)
  return enable_publish_fusion_topic_app_;
}
inline void FusionComponentInitOptions::set_enable_publish_fusion_topic_app(bool value) {
  set_has_enable_publish_fusion_topic_app();
  enable_publish_fusion_topic_app_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.enable_publish_fusion_topic_app)
}

// optional bool use_obu = 16 [default = true];
inline bool FusionComponentInitOptions::has_use_obu() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void FusionComponentInitOptions::set_has_use_obu() {
  _has_bits_[0] |= 0x00008000u;
}
inline void FusionComponentInitOptions::clear_has_use_obu() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void FusionComponentInitOptions::clear_use_obu() {
  use_obu_ = true;
  clear_has_use_obu();
}
inline bool FusionComponentInitOptions::use_obu() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.use_obu)
  return use_obu_;
}
inline void FusionComponentInitOptions::set_use_obu(bool value) {
  set_has_use_obu();
  use_obu_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.use_obu)
}

// optional bool use_vidar = 17 [default = false];
inline bool FusionComponentInitOptions::has_use_vidar() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void FusionComponentInitOptions::set_has_use_vidar() {
  _has_bits_[0] |= 0x00010000u;
}
inline void FusionComponentInitOptions::clear_has_use_vidar() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void FusionComponentInitOptions::clear_use_vidar() {
  use_vidar_ = false;
  clear_has_use_vidar();
}
inline bool FusionComponentInitOptions::use_vidar() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.use_vidar)
  return use_vidar_;
}
inline void FusionComponentInitOptions::set_use_vidar(bool value) {
  set_has_use_vidar();
  use_vidar_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.use_vidar)
}

// optional bool pub_vidar = 18 [default = false];
inline bool FusionComponentInitOptions::has_pub_vidar() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void FusionComponentInitOptions::set_has_pub_vidar() {
  _has_bits_[0] |= 0x00020000u;
}
inline void FusionComponentInitOptions::clear_has_pub_vidar() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void FusionComponentInitOptions::clear_pub_vidar() {
  pub_vidar_ = false;
  clear_has_pub_vidar();
}
inline bool FusionComponentInitOptions::pub_vidar() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.pub_vidar)
  return pub_vidar_;
}
inline void FusionComponentInitOptions::set_pub_vidar(bool value) {
  set_has_pub_vidar();
  pub_vidar_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.pub_vidar)
}

// optional bool pub_radar = 19 [default = false];
inline bool FusionComponentInitOptions::has_pub_radar() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void FusionComponentInitOptions::set_has_pub_radar() {
  _has_bits_[0] |= 0x00040000u;
}
inline void FusionComponentInitOptions::clear_has_pub_radar() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void FusionComponentInitOptions::clear_pub_radar() {
  pub_radar_ = false;
  clear_has_pub_radar();
}
inline bool FusionComponentInitOptions::pub_radar() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.pub_radar)
  return pub_radar_;
}
inline void FusionComponentInitOptions::set_pub_radar(bool value) {
  set_has_pub_radar();
  pub_radar_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.pub_radar)
}

// optional bool pub_obu = 20 [default = false];
inline bool FusionComponentInitOptions::has_pub_obu() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void FusionComponentInitOptions::set_has_pub_obu() {
  _has_bits_[0] |= 0x00080000u;
}
inline void FusionComponentInitOptions::clear_has_pub_obu() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void FusionComponentInitOptions::clear_pub_obu() {
  pub_obu_ = false;
  clear_has_pub_obu();
}
inline bool FusionComponentInitOptions::pub_obu() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.pub_obu)
  return pub_obu_;
}
inline void FusionComponentInitOptions::set_pub_obu(bool value) {
  set_has_pub_obu();
  pub_obu_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.pub_obu)
}

// optional bool use_falcon_lidar = 21 [default = true];
inline bool FusionComponentInitOptions::has_use_falcon_lidar() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void FusionComponentInitOptions::set_has_use_falcon_lidar() {
  _has_bits_[0] |= 0x00100000u;
}
inline void FusionComponentInitOptions::clear_has_use_falcon_lidar() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void FusionComponentInitOptions::clear_use_falcon_lidar() {
  use_falcon_lidar_ = true;
  clear_has_use_falcon_lidar();
}
inline bool FusionComponentInitOptions::use_falcon_lidar() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.use_falcon_lidar)
  return use_falcon_lidar_;
}
inline void FusionComponentInitOptions::set_use_falcon_lidar(bool value) {
  set_has_use_falcon_lidar();
  use_falcon_lidar_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.use_falcon_lidar)
}

// optional double falcon_lidar_filter_distance = 22;
inline bool FusionComponentInitOptions::has_falcon_lidar_filter_distance() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void FusionComponentInitOptions::set_has_falcon_lidar_filter_distance() {
  _has_bits_[0] |= 0x00200000u;
}
inline void FusionComponentInitOptions::clear_has_falcon_lidar_filter_distance() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void FusionComponentInitOptions::clear_falcon_lidar_filter_distance() {
  falcon_lidar_filter_distance_ = 0;
  clear_has_falcon_lidar_filter_distance();
}
inline double FusionComponentInitOptions::falcon_lidar_filter_distance() const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.falcon_lidar_filter_distance)
  return falcon_lidar_filter_distance_;
}
inline void FusionComponentInitOptions::set_falcon_lidar_filter_distance(double value) {
  set_has_falcon_lidar_filter_distance();
  falcon_lidar_filter_distance_ = value;
  // @@protoc_insertion_point(field_set:perception.FusionComponentInitOptions.falcon_lidar_filter_distance)
}

// repeated .perception.VirtualObject virtual_object = 23;
inline int FusionComponentInitOptions::virtual_object_size() const {
  return virtual_object_.size();
}
inline void FusionComponentInitOptions::clear_virtual_object() {
  virtual_object_.Clear();
}
inline const ::perception::VirtualObject& FusionComponentInitOptions::virtual_object(int index) const {
  // @@protoc_insertion_point(field_get:perception.FusionComponentInitOptions.virtual_object)
  return virtual_object_.Get(index);
}
inline ::perception::VirtualObject* FusionComponentInitOptions::mutable_virtual_object(int index) {
  // @@protoc_insertion_point(field_mutable:perception.FusionComponentInitOptions.virtual_object)
  return virtual_object_.Mutable(index);
}
inline ::perception::VirtualObject* FusionComponentInitOptions::add_virtual_object() {
  // @@protoc_insertion_point(field_add:perception.FusionComponentInitOptions.virtual_object)
  return virtual_object_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perception::VirtualObject >*
FusionComponentInitOptions::mutable_virtual_object() {
  // @@protoc_insertion_point(field_mutable_list:perception.FusionComponentInitOptions.virtual_object)
  return &virtual_object_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perception::VirtualObject >&
FusionComponentInitOptions::virtual_object() const {
  // @@protoc_insertion_point(field_list:perception.FusionComponentInitOptions.virtual_object)
  return virtual_object_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace perception

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perception_5fcomponent_2eproto__INCLUDED
